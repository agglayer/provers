use std::{
    future::Future,
    pin::Pin,
    sync::Arc,
    task::{Context, Poll},
};

use aggchain_proof_builder::{AggchainProofBuilder, FepVerification};
use aggchain_proof_contracts::AggchainContractsRpcClient;
use agglayer_interop::types::Digest;
use aggchain_proof_types::{AggchainProofInputs, OptimisticAggchainProofInputs};
use alloy_primitives::B256;
use futures::FutureExt as _;
use proposer_client::FepProposerRequest;
use proposer_service::ProposerService;
use tower::{util::BoxCloneService, Service as _, ServiceExt as _};
use tracing::debug;
use unified_bridge::aggchain_proof::AggchainProofPublicValues;

use crate::config::AggchainProofServiceConfig;
use crate::custom_chain_data::compute_custom_chain_data;
use crate::error::Error;

/// A request for the AggchainProofService to generate the
/// aggchain proof for the range of blocks.
#[derive(Clone, Debug)]
pub enum AggchainProofServiceRequest {
    /// Aggchain proof request information
    Normal(AggchainProofInputs),
    /// Optimistic aggchain proof request information
    Optimistic(OptimisticAggchainProofInputs),
}

/// Resulting generated Aggchain proof
pub struct AggchainProofServiceResponse {
    /// Aggchain proof generated by the `aggchain-proof-builder` service
    /// per `agg-sender` request.
    pub proof: Vec<u8>,

    /// Aggchain params
    pub aggchain_params: Digest,

    /// Aggchain verification key
    pub vkey: Vec<u8>,

    /// Last block proven before this aggchain proof.
    pub last_proven_block: u64,

    /// Last block in the aggchain proof (inclusive).
    pub end_block: u64,

    /// Local exit root calculated by the aggkit-prover for all the bridge
    /// changes included in the proof. Mismatch between LER calculation on the
    /// agglayer and the L2 is possible due to the field -
    /// `forceUpdateGlobalExitRoot`.
    pub local_exit_root_hash: Digest,

    /// Custom chain data calculated by the `aggkit-prover`, required by the
    /// agg-sender to fill in related certificate field.
    /// Consists off the two bytes for aggchain selector, 32 bytes for the
    /// output_root (new state root) and the l2 end block number.
    pub custom_chain_data: Vec<u8>,

    /// The AggchainProof's public inputs that were produced by the prover.
    pub public_values: AggchainProofPublicValues,
}

/// The Aggchain proof service is responsible for orchestrating an Aggchain
/// proof generation.
///
/// The Aggchain proof is generated by fetching the Aggregated FEP from the
/// proposer service and the `aggchain-proof-builder` service to generate the
/// Aggchain proof.
#[derive(Clone)]
pub struct AggchainProofService {
    pub(crate) proposer_service: BoxCloneService<
        proposer_client::FepProposerRequest,
        proposer_service::ProposerResponse,
        proposer_service::Error,
    >,
    pub(crate) aggchain_proof_builder: BoxCloneService<
        aggchain_proof_builder::AggchainProofBuilderRequest,
        aggchain_proof_builder::AggchainProofBuilderResponse,
        aggchain_proof_builder::Error,
    >,
}

impl AggchainProofService {
    pub async fn new(config: &AggchainProofServiceConfig) -> Result<Self, Error> {
        debug!("Initializing AggchainProofService");
        let client = prover_alloy::AlloyProvider::new(
            &config.proposer_service.l1_rpc_endpoint.url,
            prover_alloy::DEFAULT_HTTP_RPC_NODE_INITIAL_BACKOFF_MS,
            prover_alloy::DEFAULT_HTTP_RPC_NODE_BACKOFF_MAX_RETRIES,
        )
        .map_err(Error::AlloyProviderInitializationFailed)?;
        let l1_rpc_client = Arc::new(client);
        debug!("L1 RPC client initialized");

        let contract_l1_client = Arc::new(
            AggchainContractsRpcClient::new(
                config.aggchain_proof_builder.network_id,
                &config.aggchain_proof_builder.contracts,
            )
            .await
            .map_err(Error::ContractsClientInitFailed)?,
        );
        debug!("Contract L1 client initialized");

        let proposer_service = if config.proposer_service.mock {
            tower::ServiceBuilder::new()
                .service(
                    ProposerService::new_mock(&config.proposer_service, l1_rpc_client)
                        .await
                        .map_err(Error::ProposerServiceInitFailed)?,
                )
                .boxed_clone()
        } else {
            tower::ServiceBuilder::new()
                .service(
                    ProposerService::new_network(&config.proposer_service, l1_rpc_client)
                        .await
                        .map_err(Error::ProposerServiceInitFailed)?,
                )
                .boxed_clone()
        };
        debug!("ProposerService initialized");

        let aggchain_proof_builder = tower::ServiceBuilder::new()
            .service(
                AggchainProofBuilder::new(
                    &config.aggchain_proof_builder,
                    contract_l1_client.clone(),
                )
                .await
                .map_err(Error::AggchainProofBuilderInitFailed)?,
            )
            .boxed_clone();
        debug!("AggchainProofBuilder initialized");

        Ok(AggchainProofService {
            proposer_service,
            aggchain_proof_builder,
        })
    }

    fn handle_normal_request(
        &mut self,
        aggchain_proof_inputs: AggchainProofInputs,
    ) -> AggchainProofServiceFuture {
        let l1_block_hash = aggchain_proof_inputs.l1_info_tree_leaf.inner.block_hash;

        let proposer_request = FepProposerRequest {
            last_proven_block: aggchain_proof_inputs.last_proven_block,
            requested_end_block: aggchain_proof_inputs.requested_end_block,
            l1_block_hash: B256::from(l1_block_hash.0),
        };

        let mut proposer_service = self.proposer_service.clone();
        let mut proof_builder = self.aggchain_proof_builder.clone();

        async move {
            let last_proven_block = aggchain_proof_inputs.last_proven_block;
            // The ProposerResponse contains the start and end block number
            // It also contains the generated proof.
            let aggregation_proof_response = proposer_service
                .call(proposer_request)
                .await
                .map_err(Error::ProposerServiceError)?;

            let aggchain_proof_builder_request =
                aggchain_proof_builder::AggchainProofBuilderRequest {
                    fep_verification: FepVerification::Proof {
                        aggregation_proof: aggregation_proof_response.aggregation_proof,
                        aggregation_proof_public_values: aggregation_proof_response.public_values,
                    },
                    end_block: aggregation_proof_response.end_block,
                    aggchain_proof_inputs,
                };

            let end_block = aggchain_proof_builder_request.end_block;

            let aggchain_proof_response = proof_builder
                .call(aggchain_proof_builder_request)
                .await
                .map_err(Error::AggchainProofBuilderRequestFailed)?;

            let custom_chain_data =
                compute_custom_chain_data(aggchain_proof_response.output_root, end_block);

            Ok(AggchainProofServiceResponse {
                proof: aggchain_proof_response.proof,
                aggchain_params: aggchain_proof_response.aggchain_params,
                last_proven_block,
                vkey: aggchain_proof_response.vkey,
                end_block,
                local_exit_root_hash: aggchain_proof_response.new_local_exit_root,
                custom_chain_data,
                public_values: aggchain_proof_response.public_values,
            })
        }
        .boxed()
    }

    fn handle_optimistic_request(
        &mut self,
        OptimisticAggchainProofInputs {
            aggchain_proof_inputs,
            signature_optimistic_mode,
        }: OptimisticAggchainProofInputs,
    ) -> AggchainProofServiceFuture {
        let mut proof_builder = self.aggchain_proof_builder.clone();

        async move {
            let last_proven_block = aggchain_proof_inputs.last_proven_block;

            let aggchain_proof_builder_request =
                aggchain_proof_builder::AggchainProofBuilderRequest {
                    fep_verification: FepVerification::Optimistic {
                        signature: signature_optimistic_mode,
                    },
                    // In optimistic mode, the end_block is the one defined in the request.
                    end_block: aggchain_proof_inputs.requested_end_block,
                    aggchain_proof_inputs,
                };

            let end_block = aggchain_proof_builder_request.end_block;

            let aggchain_proof_response = proof_builder
                .call(aggchain_proof_builder_request)
                .await
                .map_err(Error::AggchainProofBuilderRequestFailed)?;

            let custom_chain_data =
                compute_custom_chain_data(aggchain_proof_response.output_root, end_block);

            Ok(AggchainProofServiceResponse {
                proof: aggchain_proof_response.proof,
                aggchain_params: aggchain_proof_response.aggchain_params,
                last_proven_block,
                vkey: aggchain_proof_response.vkey,
                end_block,
                local_exit_root_hash: aggchain_proof_response.new_local_exit_root,
                custom_chain_data,
                public_values: aggchain_proof_response.public_values,
            })
        }
        .boxed()
    }
}

type AggchainProofServiceFuture =
    Pin<Box<dyn Future<Output = Result<AggchainProofServiceResponse, Error>> + Send>>;

impl tower::Service<AggchainProofServiceRequest> for AggchainProofService {
    type Response = AggchainProofServiceResponse;
    type Error = Error;
    type Future = AggchainProofServiceFuture;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        std::task::ready!(self
            .proposer_service
            .poll_ready(cx)
            .map_err(Error::ProposerServiceError)?);

        self.aggchain_proof_builder
            .poll_ready(cx)
            .map_err(Error::AggchainProofBuilderInitFailed)
    }

    fn call(&mut self, req: AggchainProofServiceRequest) -> Self::Future {
        match req {
            AggchainProofServiceRequest::Normal(aggchain_proof_inputs) => {
                self.handle_normal_request(aggchain_proof_inputs)
            }
            AggchainProofServiceRequest::Optimistic(optimistic_aggchain_proof_inputs) => {
                self.handle_optimistic_request(optimistic_aggchain_proof_inputs)
            }
        }
    }
}
