use std::{
    future::Future,
    pin::Pin,
    task::{Context, Poll},
};

use aggchain_proof_builder::{AggchainProofBuilderService, Request as ProofBuilderRequest};
use proposer_service::{ProposerService, Request as ProposerRequest};

use super::error::Error;

pub struct ProofRequest {
    #[allow(dead_code)]
    pub start_block: u64,
    #[allow(dead_code)]
    pub max_block: u64,
}

pub struct ProofResponse {}

/// The Aggchain proof service is responsible for orchestrating an Aggchain
/// proof generation.
///
/// The Aggchain proof is generated by fetching the Aggregated FEP from the
/// proposer service and the aggchain proof builder service to generate the
/// Aggchain proof.
#[derive(Clone)]
pub(crate) struct AggchainProofService {
    pub(crate) proposer_service: ProposerService,
    pub(crate) aggchain_proof_builder: AggchainProofBuilderService,
}

impl Default for AggchainProofService {
    fn default() -> Self {
        Self {
            proposer_service: ProposerService { client: () },
            aggchain_proof_builder: AggchainProofBuilderService {},
        }
    }
}

impl tower::Service<ProofRequest> for AggchainProofService {
    type Response = ProofResponse;
    type Error = Error;
    type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        if self
            .proposer_service
            .poll_ready(cx)
            .map_err(|_| Error::Noop)
            .is_pending()
        {
            return Poll::Pending;
        }

        self.aggchain_proof_builder
            .poll_ready(cx)
            .map_err(|_| Error::Noop)
    }

    fn call(&mut self, _req: ProofRequest) -> Self::Future {
        let mut proposer_client = self.proposer_service.clone();
        let mut proof_builder = self.aggchain_proof_builder.clone();

        let fut = async move {
            // Fetch Aggregated FEP
            let _result = proposer_client.call(ProposerRequest {}).await.unwrap();
            // Fetch the private inputs for Aggchain proof
            proof_builder.call(ProofBuilderRequest {}).await.unwrap();
            // Generate Aggchain proof

            Ok(ProofResponse {})
        };

        Box::pin(fut)
    }
}
