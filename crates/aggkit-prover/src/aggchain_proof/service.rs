use std::{
    future::Future,
    pin::Pin,
    task::{Context, Poll},
};

use aggchain_proof_builder::{
    AggchainProof, AggchainProofBuilder, AggchainProofBuilderRequest as ProofBuilderRequest,
};
use aggkit_prover_config::aggchain_proof_service::AggchainProofServiceConfig;
use aggkit_prover_types::Hash;
use proposer_service::{ProposerRequest, ProposerService};
use tracing::debug;

use super::error::Error;

/// A request for the AggchainProofService to generate the
/// aggchain proof for the range of blocks.
#[derive(Default, Clone, Debug)]
#[allow(unused)]
pub struct AggchainProofServiceRequest {
    /// Aggchain proof starting block
    pub start_block: u64,
    /// Max number of blocks that the aggchain proof is allowed to contain
    pub max_block: u64,
    pub l1_info_tree_root_hash: Hash,
    pub l1_info_tree_leaf_hash: Hash,
    pub l1_info_tree_merkle_proof: [Hash; 32],
}

/// Resulting generated Aggchain proof
pub struct AggchainProofServiceResponse {
    pub proof: AggchainProof,
    pub start_block: u64,
    pub end_block: u64,
}

/// The Aggchain proof service is responsible for orchestrating an Aggchain
/// proof generation.
///
/// The Aggchain proof is generated by fetching the Aggregated FEP from the
/// proposer service and the `aggchain-proof-builder` service to generate the
/// Aggchain proof.
#[derive(Clone)]
pub(crate) struct AggchainProofService {
    pub(crate) proposer_service: ProposerService,
    pub(crate) aggchain_proof_builder: AggchainProofBuilder,
}

impl AggchainProofService {
    pub fn new(config: &AggchainProofServiceConfig) -> Result<Self, Error> {
        Ok(AggchainProofService {
            proposer_service: ProposerService::new(&config.proposer_service)?,
            aggchain_proof_builder: AggchainProofBuilder::new(&config.aggchain_proof_builder)?,
        })
    }
}

impl tower::Service<AggchainProofServiceRequest> for AggchainProofService {
    type Response = AggchainProofServiceResponse;
    type Error = Error;
    type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        std::task::ready!(self.proposer_service.poll_ready(cx)?);

        self.aggchain_proof_builder
            .poll_ready(cx)
            .map_err(Error::from)
    }

    fn call(&mut self, req: AggchainProofServiceRequest) -> Self::Future {
        let mut proposer_service = self.proposer_service.clone();
        let mut proof_builder = self.aggchain_proof_builder.clone();

        let fut = async move {
            // TODO: check what l1_block_number should be
            let l1_block_number = req.max_block;
            let l1_block_hash = proof_builder.get_l1_block_hash(l1_block_number).await?;

            let proposer_request = ProposerRequest {
                start_block: req.start_block,
                max_block: req.max_block,
                l1_block_number,
                l1_block_hash,
            };

            // Fetch Aggregated FEP
            let agg_span_proof_response = proposer_service.call(proposer_request).await?;

            // Fetch the private inputs for Aggchain proof
            let _aggchain_proof_builder_response = proof_builder
                .call(ProofBuilderRequest {
                    agg_span_proof: agg_span_proof_response.agg_span_proof,
                })
                .await?;

            // TODO Aggchain proof should be available here from the
            // `aggchain_proof_builder_response`
            let aggchain_proof = AggchainProof::default();
            debug!("The proof is {:?}", aggchain_proof);

            Ok(AggchainProofServiceResponse {
                proof: AggchainProof::default(),
                start_block: Default::default(),
                end_block: Default::default(),
            })
        };

        Box::pin(fut)
    }
}
