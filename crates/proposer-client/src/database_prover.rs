use std::{panic::AssertUnwindSafe, sync::Arc, time::Duration};

use alloy_primitives::B256;
use eyre::Context;
use prover_executor::{sp1_block_in_place, sp1_fast};
use sp1_sdk::{CpuProver, Prover as _, SP1ProofWithPublicValues, SP1ProvingKey, SP1VerifyingKey};

use crate::aggregation_prover::AggregationProver;

/// Prover that reads proofs from the database.
///
/// Proofs are generated by an external process (like op-succinct) and stored
/// in the database. This prover retrieves them and performs verification.
///
/// Can be configured for either:
/// - Real mode: uses real SP1 verification
/// - Mock mode: uses mock SP1 verification (for testing)
pub struct DatabaseProver {
    db_client: Arc<proposer_db_client::ProposerDBClient>,
    sp1_prover: CpuProver,
}

impl DatabaseProver {
    /// Create a new DatabaseProver with real SP1 verification.
    ///
    /// Use this for production where proofs are real proofs generated
    /// by the SP1 proving network.
    pub fn new(db_client: Arc<proposer_db_client::ProposerDBClient>) -> Self {
        DatabaseProver {
            db_client,
            sp1_prover: sp1_sdk::CpuProver::new(),
        }
    }

    /// Create a new DatabaseProver with mock SP1 verification.
    ///
    /// Use this for testing where proofs are mock proofs generated
    /// by a mock prover.
    pub fn new_mock(db_client: Arc<proposer_db_client::ProposerDBClient>) -> Self {
        DatabaseProver {
            db_client,
            sp1_prover: sp1_sdk::CpuProver::mock(),
        }
    }
}

#[async_trait::async_trait]
impl AggregationProver for DatabaseProver {
    async fn compute_pkey_vkey(
        &self,
        program: &[u8],
    ) -> eyre::Result<(SP1ProvingKey, SP1VerifyingKey)> {
        sp1_block_in_place(AssertUnwindSafe(|| self.sp1_prover.setup(program)))
    }

    async fn wait_for_proof(
        &self,
        request_id: B256,
        _timeout: Option<Duration>,
    ) -> eyre::Result<SP1ProofWithPublicValues> {
        // Extract the database request ID from the B256 request_id
        // The request_id is a 32-byte value where the last 8 bytes contain the i64 ID
        let proof_id: i64 = i64::from_be_bytes(request_id[24..].try_into()?);
        debug_assert!(request_id[..24].iter().all(|v| *v == 0));

        // Fetch the proof from the database
        let proof_bytes = self.db_client.get_agg_proof_by_id(proof_id).await?;

        // Deserialize the proof
        let proof =
            sp1_fast(|| agglayer_interop_types::bincode::default().deserialize(&proof_bytes))
                .with_context(|| format!("deserializing proof {request_id}"))?
                .with_context(|| format!("deserializing proof {request_id}"))?;

        Ok(proof)
    }

    fn verify_aggregated_proof(
        &self,
        proof: &SP1ProofWithPublicValues,
        vkey: &SP1VerifyingKey,
    ) -> eyre::Result<()> {
        sp1_fast(AssertUnwindSafe(|| self.sp1_prover.verify(proof, vkey)))
            .context("Verifying aggregated proof")?
            .context("Verifying aggregated proof")
    }
}
