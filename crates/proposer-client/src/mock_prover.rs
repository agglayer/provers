use std::{panic::AssertUnwindSafe, sync::Arc, time::Duration};

use alloy_primitives::B256;
use eyre::Context;
use prover_executor::{sp1_block_in_place, sp1_fast};
use sp1_sdk::{CpuProver, Prover as _, SP1ProofWithPublicValues, SP1ProvingKey, SP1VerifyingKey};

use crate::aggregation_prover::AggregationProver;

/// Mock prover that reads proofs from the database.
///
/// In mock mode, proofs are generated by an external process (like op-succinct)
/// and stored in the database. This prover retrieves them from the database
/// and uses SP1's mock verifier for verification.
pub struct MockProver {
    db_client: Arc<proposer_db_client::ProposerDBClient>,
    sp1_prover: CpuProver,
}

impl MockProver {
    pub fn new(db_client: Arc<proposer_db_client::ProposerDBClient>) -> Self {
        MockProver {
            db_client,
            sp1_prover: sp1_sdk::CpuProver::mock(),
        }
    }
}

#[async_trait::async_trait]
impl AggregationProver for MockProver {
    async fn compute_pkey_vkey(
        &self,
        program: &[u8],
    ) -> eyre::Result<(SP1ProvingKey, SP1VerifyingKey)> {
        sp1_block_in_place(AssertUnwindSafe(|| self.sp1_prover.setup(program)))
    }

    async fn wait_for_proof(
        &self,
        request_id: B256,
        _timeout: Option<Duration>,
    ) -> eyre::Result<SP1ProofWithPublicValues> {
        // Extract the database request ID from the B256 request_id
        // The request_id is a 32-byte value where the last 8 bytes contain the i64 ID
        let proof_id: i64 = i64::from_be_bytes(request_id[24..].try_into()?);
        debug_assert!(request_id[..24].iter().all(|v| *v == 0));

        // Fetch the proof from the database
        let proof_bytes = self.db_client.get_agg_proof_by_id(proof_id).await?;

        // Deserialize the proof
        let proof =
            sp1_fast(|| agglayer_interop_types::bincode::default().deserialize(&proof_bytes))
                .with_context(|| format!("deserializing proof {request_id}"))?
                .with_context(|| format!("deserializing proof {request_id}"))?;

        Ok(proof)
    }

    fn verify_aggregated_proof(
        &self,
        proof: &SP1ProofWithPublicValues,
        vkey: &SP1VerifyingKey,
    ) -> eyre::Result<()> {
        sp1_fast(AssertUnwindSafe(|| self.sp1_prover.verify(proof, vkey)))
            .context("Verifying aggregated proof")?
            .context("Verifying aggregated proof")
    }
}
